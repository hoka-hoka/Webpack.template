Ключевые слова:
Гит -слова система контроля версий;
Звёздочка - аналог лайка на фейсбуке;
Фолловер - лди, которые подписались на обновление;
Форк - 	копия репозитория на гитхабе;
Код ревью - проверка кода на соответствие требованиям, задачам и оформлению;
Пулл реквест - если мы изменили, что-то в своём форке и хотим добавить изменения в основной репозиторий, нужно оставить запрос (pull request). Владелец сам принимает решение о дабавлении изменений.


Для возможности отправки на сервер гит требует прохождения аутентификации по ssh-ключу. Для того, чтобы предоставить ssh-ключ его нужно сгенерировать (если этого не было сделано).
Проверим его наличие:

cd ~/.ssh
dir

Где .pub - будет открытым ключём, а второй, но без разрешения - секретным. Если их нет, то нужно запустить команду: ssh-keygen и проследовать по инструкции, в которой вначале выбирается путь сохранения ключей (C\User\user_name\.ssh\id_rsa), а затем пароль (можно оставлять пустым).

После того, как открытый ключ сгенерирован его нужно предоставить серверу Github, для дальнейшей аутинфикации при каждом новом обращении. Переходим по символической ссылку к открытому ключу копируем его. На github->user->settings->ключи-ssh>новый ключ ssh и всавляем ключ.

---------------------------------------------------------------------------------------------------СОЗДАНИЕ ФАЙЛА

mkdir hello // +folder hello
touch hello.html // create a document (touch [folder_name]/{hello.html, index.html})
git mv hello.html hello // moving
cd hello // entered into

cd .. // move one folder up
cd \ // move in root

vi text.txt // edditor text
i // edit code -> ESC
: // :wq - save and exit, :q! - without saving and exit

---------------------------------------------------------------------------------------------------СОЗДАНИЕ РЕПОЗИТОРИЯ

git init // create a local repository

-----------------------------------------------------------------------------------------ДОБАВЛЕНИЕ В РЕПОЗИТОРИЙ

привяжем редактор к git:
git config --global core.editor "'c:/program files/sublime text 3/sublime_text.exe' -w"

git add hello.html main.html img // add to index
git add -a // add all to index

git commit // only index files (oppen a editor and the firs line for comments)
git commit -m "Fires Commit" // add commit name
git commit -a // commit all monitored files

--------------------------------------------------------------------------------------------------------ИНДЕКСАЦИЯ

Каждый файл в рабочем каталоге может находится в двух состояниях: отслеживаемый и неотслеживаемый.

Отслеживаемые (Changes to be committed) это неизменённые, изменённые или готовые к комиту  которые находились в последнем снимке состояния (snapshot).

Неотслеживаемые (Untracked files) это те, которые не подготовлены к коммиту.

Если мы изменим уже отслеживаемый файл, то новая его версия попадёт в непроиндексированные отслеживаемые (Changes not staged for commit)

HEAD - это указатель на текущую ветку, которая является указателем на последний коммит, сделанный в этой ветке.

git status -s // краткая статистика (А - отслеживаемые, АМ - отредактированные, ?? - неотслеживаемые)

git cat-file -t - есть 4 типа файлов: blob (файл с данными), tree (дерево) и commit.

Для примера склонируем проект:
git clone http://...
git status - отображает отслеживаемые изменённые файлы

выведет: nothing to commit, working tree clean
Это значит, что среди отсдеживаемых нет изменённых, но добавив, например, файл README.txt всё изменится.

Проиндексируем:
git add README.txt // git add . // index all
git status

Попадёт в раздел индексируемый
Теперь мы вносим изменения в README и выполняем: git status. Видим, что README отображается, как индексируемый и неиндексируемый одновременно. Т.е. проиндексированный будет тот README, который был до вызова add.

--------------------------------------------------------------------------------------ОТМЕНА НЕПРОИНДЕКСИРОВАННЫХ

git rm readme.txt --cached // оставляет файл в рабочем каталоге, в статусе файл переходит от отслеживаемого индексирумого в неотслеживаемые. Используется, если мы проиндексировали, но забыли что-то добавить.
git rm readme.txt -f // удаляет файл из рабочего каталога, в статусе файл переходит из неиндексирумого в удалённые

В команды можно добавлять:
git rm log/\*.log -f // удалит все .log в log/
git rm \*~ // удалит все имена, которые заканчиваются на ~

git checkout --<file-name> // отменяет изменнения в файле и убирает его из отслеживаемых
git checkout -- . // отменит все

------------------------------------------------------------------------------------------------------------ТЭГИ ВЕРСИЙ

tag indicates versions
git tag v1 // create a tag of v1
git checkout v1^ // switched to another version
git tag v1-betta // create tag name for the previous version
git checkout v1 // switched to the first version

git tag // show all tags

---------------------------------------------------------------------------------------------------ОТМЕНА КОММИТОВ, ОТМЕНА ПРОИНДЕКСИРОВАННЫХ

git revert HEAD // создаётся новый комит об удалении предыдущщего, предыдущий остаётся в ветке.
git revert HEAD --no-edit // без редактора

Однако в ветке коммитов отменённый остаётся, чтобы его удалить:

git reset --soft <hash> // hash - до какого сбросить, изменения попадают в проиндексированные, неиндексированые остаются (т.е. в каталоге ничего не изменится).
git reset (or --mixed <hash>) <hash> // hash - до какого сбросить, изменения попадают в непроиндексированные и заменятся существующими в случае пересечения
git reset --hard <hash> //hash - до какого сбросить, файлы репозитория станут, как при коммите, в индекс или отслеживаемые ничего не добавится
git reset // все проиндексированные в непроиндексированные

git hist --all // view all commits and even canceled

!!! commits without tag will fall in garbage collector.

git tag -d oops // deleted the tag of "oops" and versions which link for him the garbage collector

------------------------------------------------------------------------------------------------ИЗМЕНЕНИЕ КОММИТОВ

git add <file>
git commit --amend -m "new" // changed selected commit

------------------------------------------------------------------------------------------------ВОССТАНОВЛЕНИЕ КОММИТОВ

git reflog // краткая информация о всех действиях
git log -g // все коммиты
git checkout -b dev 6771525 // создали ветку по SHA коммита из лога

Теперь удалим эту ветку и почистим файл .git/logs/

$git branch -D dev
$ rm -Rf .git/logs/

Покажет недостижимые коммиты

git fsck --full
----------------------------------------------------------------------------------------------ПРОСМОТР ИСТОРИИ КОММИТОВ

git log // все коммиты
git log -p // просмотреть, что попало в комиты
git log -p -2 // ограничить до двух последних
git log --since=2.weeks // последние две недели
git log --since="2008-01-15" // конкретная дата
git log --stat // краткая характеристика по каждому комиту

Опции:

git log --pretty=%H - хеш
%h - сокращённый комит хеш
%cd - дата коммитта
%T - хэш дерева
%an - имя автора
%ae - email автора
%ad - дата коммита (Tue Oct 23 16:22:19 2018 +0700)
%ar - относитальная дата коммита (11 day ago)
%cn - имя коммитера
%s - имя коммита

--date=short // 2011-03-09
-graph // +ASCII-график

git log --pretty=oneline // в одну строчку
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>

Пример:

$ git log --pretty=format:"%h - %an, %ar : %s"

Выведет:
ee2992f - semyon, 11 days ago : Story
6c99b88 - Sema, 8 months ago : first commit

Отображение веток:
$ git log --pretty=format:"%h - %an, %ar : %s" --graph

-----------------------------------------------------------------------------------------------------------АЛИАСЫ

C:\User\user_name -> .gitconfig
Add to a gitconfig file:
[alias]
	hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
	st = status
or comand:
git config --global alias.st status

git st -> git status

=======================================================================================ПЕРЕКЛЮЧЕНИЕ МЕЖДУ ВЕРСИЯМИ
git hist // get a history commits (see alias)
git checkout e005b34 // switch HEAD at another version (+changes in hello.html)
git checkout master // switch back
git cat hello.html // show changes

=============================================================================================ПОИСК КОММИТА, ДЕРЕВА

Существует дерево коммитов и дерево каталога.

$ git hist --max-count=1 // last commit
$ git cat-file -t <hash__commit> // type: commit
$ git cat-file -p <hash__commit> // commit info (tree, parent, 	author, commiter)
$ git ls-tree -r <hash__tree> // tree folder (all hash and files )
// best install the alias such: type and dump

=============================================================================================================ВЕТКИ

Ветка master должна содержать всегда стабильный код - выпускаемый код. Для разработки и тестирования используется ветка, называемая develop или next.
Кжадая новая ветка вначале имеет все коммиты из master. Затем, новые комииты в доп. ветке сдвигают указатель HEAD.

//------------------------//
	   СОЗДАНИЕ ВЕТКИ
//------------------------//

git checkout -b <branch name> // create a new branch and go to it
git branch // view all branch
git branch -v // view all branch and last commit in the branch
git branch master

git checkout -b style (or git branch style) // create new branch of style

//------------------------//
	 ПЕРЕКЛЮЧЕНИЕ ВЕТКИ
//------------------------//

git checkout master

//------------------------//
	    СЛИЯНИЕ ВЕТОК
//------------------------//

После того, как мы сделала всю работу и проверили её, нужно слить изменения в ветку master.

Если мы пытаемся слить одну ветку с другой, которую можно достигнуть, проследовав по истории первой, то это называется перемотка. Git в этом случае просто перемещает указатель вперёд, т. к. нет разветвлений.

Но если при работе с какой-либо веткой мы решили изменить и master, т. е. разделить историю разработки, то коммит, на котором мы уже будем находиться в ветке мастер не будет потомком другой ветки. В этом случае git сделает трёхходовое слияние. В этом слиянии примут участие: два последних состояния веток (например, master и dev) и общий для этих веток коммит-прорадитель.

Пример:

* 00bbcc0 2019-10-03 | Merge branch 'dev' [semyon] // the merge commit
|\
| * cfd8598 2019-10-03 | Semyon (dev) [semyon] // belong to a branch dev
* | 36c2eb8 2019-10-03 | Alex [semyon] // last commit in the master and branch
|/
* 59cad88 2019-10-03 | Alex [semyon]

git checkout master
git merge next

git branch --merged // show all branch then we merge branch
git branch --no-merged

//------------------------//
	   УДАЛЕНИЕ ВЕТОК
//------------------------//

После того, как изменения были слиты, ветку можно удалить. Если имеются проиндексируемые или отслеживаемые файлы, то удалять ветку так:

git branch -D <name>
Иначе
git branch -d <name>

//------------------------//
	КОФЛИКТЫ ПРИ СЛИЯНИИ
//------------------------//

Если изменить одну и ту же часть файла по-разному в двух ветках, которые собираемся слить, git не сможет сделать это чисто. git status Отобразит файлы, которые не прошли слияние.
Git добавляет стандартные маркеры к файлам, которые имеют конфликты. Такие файлы можно открыть и поправить.

//------------------------//
	СБРОС ДО СЛИЯНИЯ
//------------------------//

При слиянии все коммиты после создания и слияния ветки, что появились в master, становятся перед коммитами сливаемой ветки, даже если графически это не видно, это так. это даёт возможность отката к состоянию до слияния.

git reset --hard <hash>

//------------------------//
	ПЕРЕБАЗИРОВАНИЕ
//------------------------//

Сделали сброс до точки слияния и теперь, например, нам не нравится ветка next и мы хоим заменить её старую базу  новыми коммитами из master, которые вошли уже после создания ветки next.

git checkout next
git rebase master

Теперь, если мы снова сольём ветку next в master, то это будет обычная перемотка, т. к. база у обеих веток будет одинакова. Такой подход используют в основном при работе с локальными ветками, чтобы выглядело читабельным и небыло большого разветвления из-за разных баз.

=================================================================================Работа с локальными репозиториями

//-------------------------------//
	КЛОНИРОВАНИЕ РЕПОЗИТОРИЯ
//-------------------------------//

Из рабочего репозитория

cd ..
git clone master clone_master // created repository of clone_master as master
// let's try:
git remote // refer to the origin repository (origin - the remote repository)
// let's try more detailed
git remote show origin // view at origin repository

origin(master) - есть удалённый репозиторий, его принято размещать на сетевом сервере

Если вызвать команду git branch, то мы увидим только локальные ветки по умолчанию (master), другие же(если они есть) остались в оригинальном репозитории и чтобы увидеть их нужно выполнить:

git branch -a

Добавим изменения в оригинальный репозиторий и сделаем коммит. Теперь нужно извлечь эти изменения. Команда fetch извлекает изменения из оригинального репозитория, эти коммиты появляются в истории (git hist -a), но локальная ветка master останется указывать на прежний коммит, а не на новый. Т. е. команда не сливает изменения в основную ветку.

git fetch

Чтобы слить

git merge origin/master
git pull // git fetch + git merge

Добавим локальную ветку, которая будет отслеживать изменения в ветке next.

git branch --track next origin/next
git branch -a

Теперь при изменении оригинальной ветки next будет меняться и локальная ветка next

//-------------------------------//
	СОЗДАНИЕ ЧИСТОГО РЕПОЗИТОРИЯ
//-------------------------------//

Чистые репозитории применяются для расшаривания на каком-нибудь сетевом сервере.

git clone --bare next next.git

===========================================================================Работа с удалённым сетевым репозиторием

Удалённая ветка - это ссылка на состояние веток в удалённых репозиториях. Эти ветки двигаются всякий раз, когда происходит связь по сети (git branch --all). Они выглядят так: (имя удалённого репозитория) / (ветка). Например ветка origin/master показывает, как выглядела ветка master на сервере при последнем соединении с ним.

При клонировании с сервера проекта, git автоматически называет его origin, а также создаст указатель origin/master на то, что было в ветке master при последнем соединении. Git также сделает собственную ветку master, которая будет начинаться там же, где и ветка master в origin.

Если мы сделаем изменения в master и кто-то ещё отправит изменения на сервер, то ваши истории продолжатться по разному, до тех пор, пока снова не свяжемся с сервером.

git clone git@github.com:hoka-hoka/work.git

У локального репозитория может быть несколько удалённых. Добавим новый репозиторий, задав имя, мы можем в дальнейшем использовать его.

git remote add origin http: // добавили удалённый репозиторий (remote add [имя] [url])
git remote add <reposytory_name> ../master.git // on the desktop
git remote // show list all remote repository
git remote -v // url remote reposytory

Например, кто-то расшарил изменения на сетевом удалённом репозитории. Для этого, он мог сделать следующее:

1. Создать новый проект (git init), указать ссылку origin на git (remote), получить данные, т.е. ветку origin/master (fetch), затем слить её в локальную master (merge), поработать там.
2. Клонировать проект (clone), поработать.

Поработал, а затем запушил изменения, следовательно, удалённая ветка origin/master сместилась. Теперь нам нужно сдвинуть указатель origin/master на последние изменения в первой работе, чтобы потом замерджить в master последние изменения.

git fetch origin // extract change data
git merge origin

Но потом мы проверили работу и решили отказаться от пару коммитов (reset). После этого, чтобы расшарить изменения нужно выполнить push с флагом --force, иначе будет конфликт:

git push --force origin master

После этого необходимо обязательно уведомить всех остальных участников об откате ветки origin/master т.к. они могут не передвинуть её (fetch) и запушить комиты удалённые при откате.

Если мы пушим ветку master в чистый репозиторий, то:

git remote add origin http:// ...
git push -u origin master

Если мы сменили сервер и хотим поменять имена удалённых веток, то:

git remote rm [brnach_name] // delete branch

//-------------------------------//
	    ОТПРАВКА ИЗМЕННЕНИЙ
//-------------------------------//



Получение изменённых данных с сервера. При выполнении команды git clone извлекает весь репозиторий под псевдонимом origin. Это значит, что команда git fetch origin извлечёт все наработки.


git push <reposytory_name> master // send changes

//-------------------------------//
	    LF and CRLF
//-------------------------------//

В Unix системах конец строки это переводом строки (LF). В windows срока представлена переводом строки (LF) и каретки (CR).

git автоматически заменяет LF на CRLF. Это предупреждение можно подтвердить, как (LF->CRLF)
git config --global core.autocrlf true

И для Mac и Linux (CRF->LF)
git config --global core.autocrlf input

Если все на Windows, то можно вообще отключить:
git config --global core.autocrlf false


======================================================================================================КАТАЛОГ .GIT

1. database of objects:
cd .git/objects // compressed patch info for all commits
cd .git/objects/<patch>

2. database of config - users config. Changes .gitconfig

3. refs:
reafs/head // view branch of master
reafs/tags // view all tags

4. HEAD:
current link to branch

-----------------------------------------------------------------------------------------------
//                                              ИГНОРИРОВАНИЕ
//--------------------------------------------------------------------------------------------------

Создать .gitignore: gitignore.txt->cmd->ren gitignore.txt .gitignore (или можно просто написать .gitignore.)

cat .gitignore
*.[oa] // игнорируем все файлы, заканчивающиеся на .o или .a
+~ // игнорируем все файлы, заканчивающиеся на ~

Создадим файл .gitignore:

#не обрабатывать файлы, имя котоырх заканчивается на .а // эта строка игнорируется
*.a
#но отслеживать файл lib.a
!lib.a
#игнорировать файл TODO в корневом каталоге
/TODO
#игнорировать все файлы в каталоге build
build/
#игнорировать doc/notes.txt
doc/*.txt

//--------------------------------------------------------------------------------------------------
//                                                ИЗМЕНЕНИЯ
//--------------------------------------------------------------------------------------------------

Если нам нужно знать, что конкретно поменялось, то используем git diff. Команда сравнивает содержимое индекса с содержимым рабочего каталога.
git diff // показать непроиндексированные изменения
git diff --cached // показать проиндексированные изменения

//--------------------------------------------------------------------------------------------------
//                                                gitignore
//--------------------------------------------------------------------------------------------------


//---Предупреждения и ошибки

LF will be replaced by CRLF in ... // Windows разрыв строки кодирует двумя символами CR(перенос каретки) и LF(перенос строки), Unix только LF
$ git config --global core.autocrlf true - преобразует LF окончания